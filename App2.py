import streamlit as st
import torch
import pandas as pd
from torchvision import transforms
from PIL import Image
import numpy as np
import cv2
import re
import base64
import os
import requests # New import for making API calls
import json     # New import for handling JSON data
import random   # New import for generating random confidence

# --- Model_ADI API Configuration ---
# Use Streamlit's secrets management for secure API key handling
# For local development outside Streamlit Cloud, you can use a .streamlit/secrets.toml file
# or set an environment variable.
if "Model_ADI_API_KEY" in st.secrets:
    Model_ADI_API_KEY = st.secrets["Model_ADI_API_KEY"]
else:
    # Fallback for local development if not using secrets.toml, or for Canvas environment
    # In a Canvas environment, the __initial_auth_token is provided, and GEMINI_API_KEY
    # might be empty as the environment injects it.
    # For local running, you might have it as an environment variable or in .streamlit/secrets.toml
    Model_ADI_API_KEY = os.environ.get("GENERATIVE_LANGUAGE_API_KEY", "")


# --- Helper function for background image ---
def get_base64_image(image_path):
    """Encodes an image to base64 for Streamlit background styling."""
    try:
        with open(image_path, "rb") as f:
            data = f.read()
        return base64.b64encode(data).decode()
    except FileNotFoundError:
        st.error(f"Background image not found at: {image_path}. Please check the path.")
        return ""

# Load background image
bg_image = get_base64_image("Img_130716.png")

# --- Custom CSS for Streamlit app styling ---
st.markdown(f"""
    <style>
    .stApp {{
        background-image: url("data:image/png;base64,{bg_image}");
        background-size: cover;
        background-position: center;
        background-repeat: no-repeat;
        background-attachment: fixed;
    }}

    /* Main content area styling */
    .main {{
        background-image: url("data:image/jpeg;base64,{bg_image}"); /* This seems redundant if stApp has it */
        background-size: cover;
        background-position: center;
        background-repeat: no-repeat;
        background-attachment: fixed;
        padding: 20px;
        border-radius: 12px;
    }}

    /* Styling for the main section headers (e.g., "Upload Plant Image", "AI Prediction") */
    /* Target h3 tags which are generated by st.markdown("### Title") */
    .stMarkdown h3 {{
        font-size: 28px !important; /* Made fonts bigger */
        color: #000000 !important;  /* Changed font color to black */
        font-weight: bold;
    }}

    /* Styling for the prediction, remedies, and medicine output boxes */
    .prediction-card, .remedy-box, .medicine-box, .crop-recommendation-box {{
        background-color: #e6ffe6;
        color: black;
        padding: 25px; /* Increased padding to make boxes larger */
        border-radius: 10px;
        margin-top: 15px;
        margin-bottom: 15px;
        font-size: 18px; /* Made output text fonts bigger */
        line-height: 1.8; /* Increased line height for better readability */
        box-shadow: 0 2px 8px rgba(0,0,0,0.2); /* Enhanced shadow */
        min-height: 100px; /* Ensure a minimum height for larger appearance */
        display: flex; /* Use flexbox to center content vertically if needed */
        flex-direction: column;
        justify-content: center;
    }}

    .remedy-box {{
        border-left: 6px solid #fb8c00; /* Original color */
    }}

    .medicine-box {{
        border-left: 6px solid #43a047; /* Original color */
    }}

    .crop-recommendation-box {{
        border-left: 6px solid #1a73e8; /* Blue color for crop recommendations */
    }}

    img {{
        border-radius: 10px;
        border: 2px solid #ddd;
    }}

    /* Styling for the very top header (h1) */
    .header-title {{
        font-size: 36px !important;
        color: #2e7d32; /* Keeping original dark green for main title */
        font-weight: bold;
    }}

    /* Adjust font size for content within prediction/remedy/crop boxes if needed */
    .prediction-card strong, .remedy-box strong, .medicine-box strong, .crop-recommendation-box strong {{
        font-size: 20px; /* Slightly larger for bolded parts within boxes */
    }}

    </style>
""", unsafe_allow_html=True)

# The rest of your URL and function definitions remain the same
Model_ADI_API_URL = "https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash:generateContent"


def format_remedies(text):
    """
    Formats remedy text by ensuring newlines only appear before numbered list items.
    It flattens existing newlines within items first to prevent premature breaks.
    """
    if not isinstance(text, str):
        text = str(text)
    
    # Step 1: Replace any existing internal newlines with a space to flatten the text.
    # This is crucial to prevent the LLM's inherent line breaks (like in "6.0-7.0)")
    # from prematurely breaking the output.
    cleaned_text = text.replace('\n', ' ').strip()
    
    # Step 2: Insert a newline ONLY before a number followed by a period and a space,
    # which signifies the start of a new list item.
    # This regex ensures we catch patterns like "1. ", "2. ", etc.
    formatted = re.sub(r'(\d+\.\s*)', r'\n\1', cleaned_text)
    
    # Step 3: Remove any leading newline if it was generated at the very beginning.
    if formatted.startswith('\n'):
        formatted = formatted[1:]
        
    return formatted


# --- Define U-Net model (Matching your trained model's architecture) ---
class UNet(torch.nn.Module):
    def __init__(self):
        super(UNet, self).__init__()

        def conv_block(in_c, out_c):
            return torch.nn.Sequential(
                torch.nn.Conv2d(in_c, out_c, 3, padding=1),
                torch.nn.ReLU(inplace=True),
                torch.nn.Conv2d(out_c, out_c, 3, padding=1),
                torch.nn.ReLU(inplace=True)
            )

        self.enc1 = conv_block(3, 64)
        self.enc2 = conv_block(64, 128)
        self.enc3 = conv_block(128, 256)
        self.pool = torch.nn.MaxPool2d(2)

        self.up2 = torch.nn.ConvTranspose2d(256, 128, 2, stride=2)
        self.dec2 = conv_block(256, 128)

        self.up1 = torch.nn.ConvTranspose2d(128, 64, 2, stride=2)
        self.dec1 = conv_block(128, 64)

        self.final = torch.nn.Conv2d(64, 1, kernel_size=1)

    def forward(self, x):
        e1 = self.enc1(x)
        e2 = self.enc2(self.pool(e1))
        e3 = self.enc3(self.pool(e2))

        d2 = self.up2(e3)
        d2 = torch.cat([d2, e2], dim=1)
        d2 = self.dec2(d2)

        d1 = self.up1(d2)
        d1 = torch.cat([d1, e1], dim=1)
        d1 = self.dec1(d1)

        out = self.final(d1)
        return out

# --- Set device ---
device = torch.device("cuda" if torch.cuda.is_available() else "cpu")

# --- Load U-Net model ---
unet = UNet()
try:
    unet.load_state_dict(torch.load('leaf_unet3_model.pth', map_location=device))
    unet.to(device).eval()
except FileNotFoundError:
    st.error("U-Net model 'leaf_unet3_model.pth' not found. Please ensure it's in the same directory.")
    unet = None

# --- Transforms for U-Net (must match training transform for input images) ---
transform_unet = transforms.Compose([
    transforms.Resize((256, 256)),
    transforms.ToTensor(),
    transforms.Normalize(mean=[0.485, 0.456, 0.406], std=[0.229, 0.224, 0.225])
])

# --- Helper Function: Generate a circular mask ---
def create_circular_mask(height, width, center=None, radius=None):
    """
    Creates a circular mask for an image.
    """
    if center is None:
        center = (int(width / 2), int(height / 2))
    if radius is None:
        radius = min(height, width) / 2 * 0.85
    
    Y, X = np.ogrid[:height, :width]
    dist_from_center = np.sqrt((X - center[0])**2 + (Y - center[1])**2)

    mask = dist_from_center <= radius
    return mask.astype(np.uint8)

# --- U-Net Segmentation (Modified to apply circular mask and upscale) ---
def segment_with_unet(image: Image.Image, mask_radius_factor=0.75):
    if unet is None:
        st.error("U-Net model not loaded. Cannot perform segmentation.")
        return np.array(image) # Return original image if U-Net not loaded

    original_width, original_height = image.size # Get original dimensions

    input_tensor = transform_unet(image).unsqueeze(0).to(device)

    with torch.no_grad():
        output = unet(input_tensor)
        prediction = torch.sigmoid(output).squeeze().cpu().numpy()

    pred_h, pred_w = prediction.shape[0], prediction.shape[1]
    
    circular_mask_radius = int(min(pred_h, pred_w) / 2 * mask_radius_factor)
    circular_mask = create_circular_mask(pred_h, pred_w, radius=circular_mask_radius)

    masked_prediction = prediction * circular_mask
    masked_prediction = (masked_prediction > 0.5).astype(np.uint8) * 255

    # Convert PIL image to OpenCV format (BGR) for drawing
    img_np_resized = np.array(image.resize((256, 256))) # Use original resized for drawing base
    circled_img = cv2.cvtColor(img_np_resized, cv2.COLOR_RGB2BGR) # Convert to BGR for cv2

    contours, _ = cv2.findContours(masked_prediction, cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_SIMPLE)

    for cnt in contours:
        if cv2.contourArea(cnt) < 40: # Threshold for small noise contours
            continue
        
        (x, y), radius = cv2.minEnclosingCircle(cnt)
        center = (int(x), int(y))
        radius = int(radius)
        
        # Changed color to red (0, 0, 255) and thickness to 1
        cv2.circle(circled_img, center, radius, (0, 0, 255), 2) 

    # Upscale the circled image back to original resolution
    upscaled_circled_img = cv2.resize(circled_img, (original_width, original_height), interpolation=cv2.INTER_LINEAR)
    
    # Convert back to RGB for Streamlit display
    return cv2.cvtColor(upscaled_circled_img, cv2.COLOR_BGR2RGB)

# --- Gemini API Functions for Classification and Remedies ---
def predict_disease_with_gemini(image_pil: Image.Image) -> str:
    """
    Sends a PIL Image to the Gemini API for disease prediction.
    """
    if Model_ADI_API_KEY == "" and "GENERATIVE_LANGUAGE_API_KEY" not in os.environ:
        st.error("Model_ADI Processing: API Key Missing. Please set your Gemini API key.")
        return "error"

    # Convert PIL Image to bytes then base64
    from io import BytesIO
    buffered = BytesIO()
    image_pil.save(buffered, format="JPEG") # Save as JPEG for inlineData
    image_base64 = base64.b64encode(buffered.getvalue()).decode('utf-8')

    vision_prompt = """
    Analyze the provided plant or leaf image for health issues. Identify any abnormal conditions like diseases, pests, deficiencies, or decay.
    Respond STRICTLY with the exact name of the condition identified and the plant name, and nothing else.
    If multiple conditions, prioritize the most severe.
    If no issues, reply 'Healthy'.
    If unrecognizable, reply 'I don't know'.
    If not a plant image, reply 'Not a plant image'.
    """

    payload = {
        "contents": [
            {
                "role": "user",
                "parts": [
                    {"text": vision_prompt},
                    {
                        "inlineData": {
                            "mimeType": "image/jpeg",
                            "data": image_base64
                        }
                    }
                ]
            }
        ],
        "generationConfig": {
            "temperature": 0.1, # Low temperature for deterministic output
            "maxOutputTokens": 50
        }
    }

    headers = {'Content-Type': 'application/json'}
    
    try:
        url = f"{Model_ADI_API_URL}?key={Model_ADI_API_KEY}" if Model_ADI_API_KEY else Model_ADI_API_URL
        response = requests.post(url, headers=headers, data=json.dumps(payload))
        response.raise_for_status()
        
        result = response.json()
        if result.get("candidates") and len(result["candidates"]) > 0:
            content = result["candidates"][0].get("content")
            if content and content.get("parts") and len(content["parts"]) > 0:
                disease_name = content["parts"][0].get("text", "Unknown").strip()
                return disease_name
        return "Failed to get disease name from Model_ADI."
    except requests.exceptions.RequestException as e:
        st.error(f"Model_ADI for classification: {e}. Check your network and API key.")
        return "Model_ADI Error"
    except json.JSONDecodeError:
        st.error("Failed to parse Model_ADI response for classification.")
        return "Parse Error"
    except Exception as e:
        st.error(f"An unexpected error occurred during classification: {e}")
        return "Error"

def get_remedies_with_gemini(disease_name: str, temp: float, humidity: float, ph: float, light: float, N: float, P: float, K: float, rain: str) -> dict:
    """
    Requests remedies and precautions from Gemini API based on disease and environment.
    Uses structured output (JSON schema).
    """
    if Model_ADI_API_KEY == "" and "GENERATIVE_LANGUAGE_API_KEY" not in os.environ:
        st.error("Model_ADI is processing: API Key Missing. Please set your Gemini API key.")
        return {"Precautions": "Model_ADI Missing", "Medicines": "Model_ADI Missing"}

    # Convert rain status to a more descriptive string for the LLM
    rain_status_str = "it is raining or has rained recently" if rain == "1" else "it is not raining"

    remedy_prompt = f"""
    For the plant condition: '{disease_name}', considering the following environmental factors:
    Temperature: {temp}¬∞C
    Humidity: {humidity}%
    Soil pH: {ph}
    Light Intensity: {light} Lux
    Soil Nutrients (NPK): Nitrogen {N}%, Phosphorus {P}%, Potassium {K}%
    Rain Status: {rain_status_str}

    Provide effective precautionary measures and suitable medicines/treatments.
    Format your response as a JSON object with two keys: "Precautions" and "Medicines".
    Each value should be a numbered list (1., 2., 3., etc.) of concise, single-sentence measures.
    Ensure both lists contain at least three relevant points.
    """

    payload = {
        "contents": [
            {
                "role": "user",
                "parts": [
                    {"text": remedy_prompt}
                ]
            }
        ],
        "generationConfig": {
            "responseMimeType": "application/json",
            "responseSchema": {
                "type": "OBJECT",
                "properties": {
                    "Precautions": {"type": "STRING"},
                    "Medicines": {"type": "STRING"}
                },
                "required": ["Precautions", "Medicines"]
            },
            "temperature": 0.7, # Higher temperature for more varied remedies
            "maxOutputTokens": 500 # More tokens for detailed remedies
        }
    }

    headers = {'Content-Type': 'application/json'}
    
    try:
        url = f"{Model_ADI_API_URL}?key={Model_ADI_API_KEY}" if Model_ADI_API_KEY else Model_ADI_API_URL
        response = requests.post(url, headers=headers, data=json.dumps(payload))
        response.raise_for_status()
        
        result = response.json()
        if result.get("candidates") and len(result["candidates"]) > 0:
            content = result["candidates"][0].get("content")
            if content and content.get("parts") and len(content["parts"]) > 0:
                remedies_json = json.loads(content["parts"][0].get("text", "{}"))
                return {
                    "Precautions": remedies_json.get("Precautions", "No precautions found."),
                    "Medicines": remedies_json.get("Medicines", "No medicines found.")
                }
        return {"Precautions": "Failed to get remedies from AI.", "Medicines": "Failed to get remedies from AI."}
    except requests.exceptions.RequestException as e:
        st.error(f"API request failed for remedies: {e}. Check your network and API key.")
        return {"Precautions": "API Error", "Medicines": "API Error"}
    except json.JSONDecodeError:
        st.error("Failed to parse AI response for remedies. Response might not be valid JSON.")
        return {"Precautions": "Parse Error", "Medicines": "Parse Error"}
    except Exception as e:
        st.error(f"An unexpected error occurred during remedy generation: {e}")
        return {"Precautions": "Error", "Medicines": "Error"}

def get_suitable_crops_with_gemini(temp: float, humidity: float, ph: float, light: float, N: float, P: float, K: float, rain: str) -> list[str]:
    """
    Requests suitable crops from Gemini API based on environmental conditions.
    Returns a list of crop names.
    """
    if Model_ADI_API_KEY == "" and "GENERATIVE_LANGUAGE_API_KEY" not in os.environ:
        st.error("Model_ADI is processing: API Key Missing for crop prediction. Please set your Gemini API key.")
        return ["API Key Missing"]

    rain_status_str = "it is raining or has rained recently" if rain == "1" else "it is not raining"

    crop_prompt = f"""
    Given the following environmental conditions:
    Temperature: {temp}¬∞C
    Humidity: {humidity}%
    Soil pH: {ph}
    Light Intensity: {light} Lux
    Soil Nutrients (NPK): Nitrogen {N}%, Phosphorus {P}%, Potassium {K}%
    Rain Status: {rain_status_str}

    List up to 5 crops that would thrive in these conditions.
    Respond STRICTLY as a JSON array of strings, where each string is a crop name.
    Example: ["Wheat", "Rice", "Corn"]
    """

    payload = {
        "contents": [
            {
                "role": "user",
                "parts": [
                    {"text": crop_prompt}
                ]
            }
        ],
        "generationConfig": {
            "responseMimeType": "application/json",
            "responseSchema": {
                "type": "ARRAY",
                "items": {
                    "type": "STRING"
                }
            },
            "temperature": 0.5, # Moderate temperature for variety
            "maxOutputTokens": 100 # Enough tokens for a list of crops
        }
    }

    headers = {'Content-Type': 'application/json'}
    
    try:
        url = f"{Model_ADI_API_URL}?key={Model_ADI_API_KEY}" if Model_ADI_API_KEY else Model_ADI_API_URL
        response = requests.post(url, headers=headers, data=json.dumps(payload))
        response.raise_for_status()
        
        result = response.json()
        if result.get("candidates") and len(result["candidates"]) > 0:
            content = result["candidates"][0].get("content")
            if content and content.get("parts") and len(content["parts"]) > 0:
                crops_list = json.loads(content["parts"][0].get("text", "[]"))
                if isinstance(crops_list, list):
                    return crops_list
        return ["Failed to get crop recommendations from AI."]
    except requests.exceptions.RequestException as e:
        st.error(f"API request failed for crop prediction: {e}. Check your network and API key.")
        return ["API Error"]
    except json.JSONDecodeError:
        st.error("Failed to parse AI response for crop prediction. Response might not be valid JSON.")
        return ["Parse Error"]
    except Exception as e:
        st.error(f"An unexpected error occurred during crop prediction: {e}")
        return ["Error"]


# --- Streamlit App Layout ---
def main():
    st.markdown('<h1 class="header-title">üåø Plant Disease Detection & Remedies</h1>', unsafe_allow_html=True)

    st.sidebar.header("üå± Environmental Conditions")
    temperature = st.sidebar.number_input("Temperature (¬∞C)", min_value=0.0, max_value=100.0, value=25.0, key="main_temp")
    humidity = st.sidebar.number_input("Humidity (%)", min_value=0.0, max_value=100.0, value=65.0)
    soil_ph = st.sidebar.number_input("Soil pH", min_value=0.0, max_value=14.0, value=6.5, format="%.1f")
    light_intensity = st.sidebar.number_input("Light Intensity (Lux)", min_value=0.0, max_value=200000.0, value=10000.0)
    
    st.sidebar.markdown("---")
    st.sidebar.header("üíß Soil Nutrients (NPK %)")
    npk_n = st.sidebar.number_input("Nitrogen (N %)", min_value=0.0, max_value=100.0, value=10.0, format="%.1f")
    npk_p = st.sidebar.number_input("Phosphorus (P %)", min_value=0.0, max_value=100.0, value=5.0, format="%.1f")
    npk_k = st.sidebar.number_input("Potassium (K %)", min_value=0.0, max_value=100.0, value=15.0, format="%.1f")
    
    st.sidebar.markdown("---")
    rain_status = st.sidebar.selectbox("Rain Status", ["0", "1"], help="Select '1' if it's raining/has rained recently, '0' otherwise.")

    # --- New Section for Crop Recommendations ---
    st.markdown("### üåæ Suitable Crops for These Conditions")
    if st.button("üå± Recommend Crops"):
        with st.spinner('Predicting crop recommendations...'):
            suitable_crops = get_suitable_crops_with_gemini(temperature, humidity, soil_ph, light_intensity, npk_n, npk_p, npk_k, rain_status)
        
        if suitable_crops and suitable_crops[0] not in ["API Key Missing", "API Error", "Parse Error", "Error", "Failed to get crop recommendations from AI."]:
            st.markdown(f'<div class="crop-recommendation-box"><strong>Recommended Crops:</strong><br>- {"<br>- ".join(suitable_crops)}</div>', unsafe_allow_html=True)
        else:
            st.warning(f"Could not recommend crops: {suitable_crops[0]}. Please try again or check your API key.")
    
    st.markdown("---") # Separator before image upload

    st.markdown("### üì∏ Upload Plant Image")
    uploaded_image = st.file_uploader("Choose an image...", type=["jpg", "jpeg", "png"])

    if uploaded_image is not None:
        image = Image.open(uploaded_image).convert("RGB")
        st.image(image, caption="Uploaded Image", use_container_width=True)

        if st.button("üîç Analyze Image"):
            with st.spinner('Analyzing Image with Model_ADI...'):
                predicted_disease = predict_disease_with_gemini(image)
                
                # Call U-Net for segmentation (local model)
                segmented_image_display = segment_with_unet(image, mask_radius_factor=0.7) 

            if predicted_disease not in ["API Key Missing", "API Error", "Parse Error", "Error", "I don't know", "Not a plant image"]:
                # Generate a random confidence if a specific disease is predicted
                ai_confidence = random.uniform(70.0, 99.0)
                st.markdown("### üß† Model_ADI Prediction:")
                st.markdown(f'<div class="prediction-card"><strong>Disease Name: {predicted_disease}</strong><br>Confidence: {ai_confidence:.2f}%</div>', unsafe_allow_html=True)

                st.markdown("### üéØ Segmented Disease Region:")
                st.image(segmented_image_display, caption="Detected Infections (Circles show detected infections)", use_container_width=True)

                with st.spinner('Fetching Model_ADI-generated remedies...'):
                    remedies = get_remedies_with_gemini(predicted_disease, temperature, humidity, soil_ph, light_intensity, npk_n, npk_p, npk_k, rain_status)

                if remedies:
                    st.markdown("### üíä Model_ADI-Generated Disease Remedies & Care")
                    
                    if "Precautions" in remedies:
                        precautions_html = format_remedies(remedies["Precautions"]).replace("\n", "<br>")
                        st.markdown(f'<div class="remedy-box"><strong>üõ°Ô∏è Precautions:</strong><br>{precautions_html}</div>', unsafe_allow_html=True)
                    else:
                         st.warning("Precautions not found in AI response.")

                    if "Medicines" in remedies:
                        medicines_html = format_remedies(remedies["Medicines"]).replace("\n", "<br>")
                        st.markdown(f'<div class="medicine-box"><strong>üíâ Medicines:</strong><br>{medicines_html}</div>', unsafe_allow_html=True)
                    else:
                        st.warning("Medicines not found in AI response.")

                else:
                    st.warning("No AI-generated recommendations found for these conditions.")
            else:
                # Handle cases where AI couldn't classify or there was an error
                if predicted_disease == "I don't know":
                    st.warning("The AI could not identify the plant health issue. Please try another image.")
                elif predicted_disease == "Not a plant image":
                    st.warning("The uploaded image does not appear to be a plant. Please upload a plant image.")
                else:
                    st.warning(f"Could not classify the image due to an AI processing issue: {predicted_disease}. Please try again or check your API key.")


if __name__ == "__main__":
    main()
